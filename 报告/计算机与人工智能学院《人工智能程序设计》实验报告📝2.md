## ![img](https://cnchen2000.oss-cn-shanghai.aliyuncs.com/img/logo.png)      计算机与人工智能学院《人工智能程序设计》实验报告📝

| 专业                 | 学号         | 姓名         |
| :------------------- | ------------ | ------------ |
| 数据科学与大数据技术 | 2301230818   | 邓逸轩       |
| **课程名称**         | **实验名称** | **完成日期** |
| 专业综合训练I        | 实验二       | 2025.3.25    |



[TOC]

### 一 实验目标

- 掌握 lambda 表达式的使用
- 掌握 Currying 概念，能够将多参数函数转换为单参数链的高阶函数。
- 运用高阶函数解决实际编程问题，如实现函数的 currying、组合、计数条件判断等功能。
- 学会编写测试用例对函数功能进行全面测试。
- 熟练使用 Markdown 格式撰写实验记录文档。

### 二 实验要求

- 必须个人独立完成实验，积极主动进行编程实践。
- 可与同学交流探讨思路，但严禁抄袭他人源码。
- 严格按照实验说明文档的各个步骤进行操作，并认真撰写实验报告。
- 能够在实验过程中进行演示，并清晰阐述各功能的主要代码模块。
- 实验报告需着重突出个人在实验中的想法、做法以及心得体会。

### 三 实验环境

​	我所使用的实验环境：

- 使用VScode进行编写代码，并使用conda配置python的虚拟环境进行运行
- 使用Typora进行编写Markdown的记录文档

### 四 实验内容

### 1. 函数定义

- **`lambda_curry2`函数**：目的是将一个双参数函数`FUNC`转换为柯里化版本。柯里化是把多参数函数转化为单参数函数链的过程，该函数接收一个双参数函数，返回一个经过柯里化处理的新函数。
- **`count_cond`函数**：此函数接收一个双参数的谓词函数`Condition`，返回一个单参数函数。该单参数函数接收参数`N`，统计从 1 到`N`中满足`Condition`条件的数字个数，其中`Condition`的第一个参数为`N`，第二个参数为从 1 到`N`的数字。
- **`composite_identity`函数**：接受两个单参数函数`f`和`g`，返回一个单参数`x`的函数。该返回函数用于判断`f(g(x))`是否等于`g(f(x))`。
- **`cycle`函数**：接收三个函数`f1`、`f2`、`f3`，返回一个高阶函数。这个高阶函数接受一个整数参数`n`，并再次返回一个函数，该最终返回的函数接受一个参数`x`，并根据`n`的值循环地将`f1`、`f2`、`f3`应用到`x`上。

### 2. 函数功能实现

- `lambda_curry2`函数
  - **实现步骤**：利用 lambda 表达式创建一个嵌套结构。外层 lambda 接收第一个参数`x`，内层 lambda 接收第二个参数`y`，在内层 lambda 中调用原始的双参数函数`func`，并传入`x`和`y`。
  - **实现方法**：借助 Python 中 lambda 表达式简洁的语法，通过函数嵌套实现柯里化。代码如下：

```python
def lambda_curry2(func):
    return lambda x: lambda y: func(x, y)
```

- **测试说明**：通过从`operator`模块导入`add`、`mul`、`mod`等函数进行测试。例如，先对`add`函数进行柯里化，得到`curried_add`，再使用`curried_add(3)`得到一个新函数`add_three`，最后调用`add_three(5)`，预期结果为 8。对`mul`和`mod`函数进行类似测试，验证柯里化的正确性。
- `count_cond`函数
  - **实现步骤**：定义一个内部函数`count`，在`count`函数内部，使用`for`循环从 1 遍历到`N`。在每次循环中，调用传入的条件函数`condition`，判断当前数字是否满足条件，若满足则计数器加 1。最后返回计数器的值。
  - **实现方法**：运用闭包的特性，将条件函数`condition`保存在内部函数`count`的作用域中。代码如下：

```python
def count_cond(condition):
    def count(n):
        counter = 0
        for i in range(1, n + 1):
            if condition(n, i):
                counter += 1
        return counter
    return count
```

- **测试说明**：定义不同的条件函数进行测试。如定义`count_factors`用于统计因数个数，通过`count_factors(2)`、`count_factors(4)`、`count_factors(12)`等测试用例，验证统计结果是否正确。再定义`is_prime`条件函数用于判断质数，通过`count_primes(2)`、`count_primes(3)`等测试用例，检验对质数的统计是否准确。
- `composite_identity`函数
  - **实现步骤**：借助已定义的`composer`函数，创建两个组合函数`f_of_g`和`g_of_f`，分别表示`f(g(x))`和`g(f(x))`。然后返回一个新函数，该函数接收参数`x`，比较`f_of_g(x)`和`g_of_f(x)`是否相等。
  - **实现方法**：利用`composer`函数实现函数组合，通过简单的比较逻辑判断两个组合函数的结果。代码如下：

```python
def composite_identity(f, g):
    f_of_g = composer(f, g)
    g_of_f = composer(g, f)
    return lambda x: f_of_g(x) == g_of_f(x)
```

- **测试说明**：定义`add_one`和`square`等函数，通过`composite_identity(square, add_one)(0)`、`composite_identity(square, add_one)(4)`等测试用例，验证函数是否能正确判断两个函数组合的恒等性。
- `cycle`函数
  - **实现步骤**：定义一个外层函数`outer`，接收参数`n`。在`outer`函数内部，再定义一个内层函数`inner`，接收参数`x`。在`inner`函数中，使用`for`循环`n`次，根据循环次数`i`对 3 取模的结果，依次应用`f1`、`f2`、`f3`到`x`上。最后返回`inner`函数。
  - **实现方法**：通过多层函数嵌套和循环控制，实现函数的循环应用。代码如下：

```python
def cycle(f1, f2, f3):
    def outer(n):
        def inner(x):
            for i in range(n):
                if i % 3 == 0:
                    x = f1(x)
                elif i % 3 == 1:
                    x = f2(x)
                else:
                    x = f3(x)
            return x
        return inner
    return outer
```

- **测试说明**：定义`add1`、`times2`、`add3`等函数，通过`cycle(add1, times2, add3)(0)(5)`、`cycle(add1, times2, add3)(2)(1)`等测试用例，验证函数在不同循环次数下对输入值的处理是否符合预期。

### 3. 函数语法检查

- **`lambda_curry2_syntax_check`函数**：此函数运用`inspect`和`ast`模块，检查`lambda_curry2`函数的源代码。通过解析源代码的抽象语法树，确认函数主体仅包含一个表达式和一个返回语句，以此保证函数定义的语法结构符合要求，防止因语法错误导致函数功能异常。

### 4. 测试用例验证

针对每个函数，均设计了丰富的测试用例进行验证。通过不同类型的输入值，全面检查函数在各种情况下的输出是否符合预期。这些测试用例不仅覆盖了正常情况，还包含了边界值和一些特殊情况，确保函数的稳定性和正确性。例如，在`lambda_curry2`函数测试中，对不同运算性质的双参数函数（加法、乘法、取模）进行柯里化测试；在`count_cond`函数测试中，对统计因数和质数等不同条件下的计数功能进行验证；在`composite_identity`函数测试中，对不同函数组合的恒等性判断进行测试；在`cycle`函数测试中，对不同循环次数和函数应用顺序进行测试。通过这些全面的测试，有效保障了函数的质量，使其能够在实际应用中可靠运行。

### 五 实验心得

##### currying化

在理解柯里化的时候，并没有太大问题，但是当自己使用的时候，我发现使用并不是那么简单，因为如何根据部分参数进行设计，封装成函数的这个决策并不熟练。感觉个人对这个概念理解并不够深入，我去bilbilil找了专门对柯里化的讲解视频。

