## ![img](https://cnchen2000.oss-cn-shanghai.aliyuncs.com/img/logo.png)      è®¡ç®—æœºä¸äººå·¥æ™ºèƒ½å­¦é™¢ã€Šäººå·¥æ™ºèƒ½ç¨‹åºè®¾è®¡ã€‹å®éªŒæŠ¥å‘ŠğŸ“

| ä¸“ä¸š                 | å­¦å·         | å§“å         |
| :------------------- | ------------ | ------------ |
| æ•°æ®ç§‘å­¦ä¸å¤§æ•°æ®æŠ€æœ¯ | 2302320122   | èƒ¡æ–‡éŸ¬       |
| **è¯¾ç¨‹åç§°**         | **å®éªŒåç§°** | **å®Œæˆæ—¥æœŸ** |
| äººå·¥æ™ºèƒ½ç¨‹åºè®¾è®¡A        | hw02       | 2025.3.20    |



[TOC]

---



### ä¸€ å®éªŒç›®æ ‡

â€‹	å­¦ä¹ å’Œå®è·µé«˜é˜¶å‡½æ•°çš„ä½¿ç”¨ï¼Œé€šè¿‡ç¼–å†™å’Œæµ‹è¯•å¤šä¸ªå‡½æ•°æ¥æŒæ¡ä»¥ä¸‹æ ¸å¿ƒæ¦‚å¿µå’ŒæŠ€èƒ½ï¼š

- é«˜é˜¶å‡½æ•°çš„ç†è§£ä¸åº”ç”¨
- å‡½æ•°å¼ç¼–ç¨‹å®è·µ
- é€’å½’å’Œè¿­ä»£
- æŠ½è±¡ä¸æ³›åŒ–

---



### äºŒ å®éªŒè¦æ±‚

- ä¸ªäººç‹¬ç«‹å®Œæˆï¼Œç§¯æåŠ¨æ‰‹ç¼–ç¨‹ï¼›
- é¼“åŠ±ä¸åŒå­¦äº¤æµï¼Œä½†ä¸èƒ½æŠ„è¢­æºç ï¼›
- èƒ½å®Œæˆå®éªŒè¯´æ˜æ–‡æ¡£çš„å„ä¸ªæ­¥éª¤å¹¶æ’°å†™æ­¤å®éªŒæŠ¥å‘Šï¼›
- èƒ½æ¼”ç¤ºå®éªŒè¿‡ç¨‹å¹¶é˜è¿°åŠŸèƒ½çš„ä¸»è¦ä»£ç æ¨¡å—ã€‚
- å®éªŒæŠ¥å‘Šè¯·çªå‡ºè‡ªå·±çš„**æƒ³æ³•**ã€**åšæ³•**ã€**å¿ƒå¾—ä½“ä¼š**ï¼›

---



### ä¸‰ å®éªŒç¯å¢ƒ

- è½¯ä»¶ï¼šVs code
- ç¯å¢ƒï¼špython=3.10

---



### å›› å®éªŒå†…å®¹ 

åŸºäºå‡ ä¸ªé—®é¢˜ï¼Œé€šè¿‡ç¼–å†™å‡½æ•°æ¥å·©å›ºå’Œç»ƒä¹ é«˜é˜¶å‡½æ•°çš„ä½¿ç”¨ï¼ŒåŒ…æ‹¬é€’å½’å’Œè¿­ä»£ç­‰æ¦‚å¿µã€‚

### 1. **`count_until_larger`å‡½æ•°**

å‡½æ•°è¦æ±‚ï¼šå®ç°å‡½æ•° count_until_larger , è¯¥å‡½æ•°æ¥å—ä¸€ä¸ªæ­£æ•´æ•° num ï¼Œç»Ÿè®¡æœ€å³è¾¹æ•°ä½ï¼ˆdigitï¼‰å’Œç¦»å®ƒæœ€è¿‘å¹¶æ¯”å®ƒå¤§çš„æ•°ä½çš„è·ç¦»ã€‚æ˜¯è¿™æ ·åšçš„ï¼Œå‡½æ•°ä»å³å¾€å·¦è®¡æ•°ï¼Œä¸€æ—¦é‡åˆ°æ¯”æœ€å³è¾¹æ•°ä½å¤§çš„æ•°ä½ï¼Œå°±è¿”å›è¿™ä¸ªè®¡æ•°ï¼Œå¦‚æœä¸å­˜åœ¨è¿™æ ·çš„æ•°ä½ï¼Œå°±è¿”å› -1

**ä»£ç å®ç°**ï¼š

```python
def count_until_larger(num):
    """
    Complete the function count_until_larger that takes in a positive integer num.
    count_until_larger examines the rightmost digit and counts digits from right to
    left until it encounters a digit larger than the rightmost digit, then returns that count.

    >>> count_until_larger(117) # .Case 1
    -1
    >>> count_until_larger(8117) # .Case 2
    3
    >>> count_until_larger(9118117) # .Case 3
    3
    >>> count_until_larger(8777)  # .Case 4
    3
    >>> count_until_larger(22) # .Case 5
    -1
    >>> count_until_larger(0) # .Case 6
    -1
    """
    if num == 0:
        return -1
    rightmost = num % 10
    count = 0
    num = num // 10
    while num > 0:
        count += 1
        current_digit = num % 10
        if current_digit > rightmost:
            return count
        num = num // 10
    return -1
```

æµ‹è¯•ç»“æœ:
![img](https://github.com/Victor-Tau/cs61a/blob/master/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/figs/hw02/1.png?raw=True)

---

### 2. **`filter_sequence`å‡½æ•°**

ç¼–å†™å‡½æ•° `filter_sequence` ï¼Œæ¥å—ä¸¤ä¸ªæ•´æ•° `start` å’Œ `stop` ï¼Œå’Œä¸€ä¸ªå‡½æ•° `cond`ï¼Œ`cond` æ¥å—ä¸€ä¸ªå‚æ•°å¹¶è¾“å‡ºä¸€ä¸ªå¸ƒå°”å€¼ã€‚å½“ `cond` è¿”å› `True` æ—¶ï¼Œ`filter_sequence` è¿”å›ä» `start` åˆ° `stop` ï¼ˆåŒ…æ‹¬ï¼‰çš„æ‰€æœ‰æ•°ä½ï¼ˆdigitï¼‰ä¹‹å’Œã€‚

**ä»£ç å®ç°**ï¼š

```python
def filter_sequence(cond, start, stop):
    """
    Returns the sum of numbers from start (inclusive) to stop (inclusive) that satisfy
    the one-argument function cond.

    >>> filter_sequence(lambda x: x % 2 == 0, 0, 10) # .Case 1
    30
    >>> filter_sequence(lambda x: x % 2 == 1, 0, 10) # .Case 2
    25
    """
    total = 0
    for num in range(start, stop + 1):
        if cond(num):
            total += num
    return total
```

æµ‹è¯•ç»“æœï¼š![img](https://github.com/Victor-Tau/cs61a/blob/master/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/figs/hw02/2.png?raw=True)

---

### 3. **`Hailstone`**

å‡½æ•°è¦æ±‚ï¼š
Douglas Hofstadter çš„æ™®åˆ©ç­–å¥–è·å¥–è‘—ä½œã€Š*GÃ¶delï¼Œ Escherï¼Œ Bach*ã€‹æå‡ºäº†ä»¥ä¸‹æ•°å­¦éš¾é¢˜ã€‚

1. é€‰æ‹©ä¸€ä¸ªæ­£æ•´æ•° `n` ä½œä¸ºå¼€å§‹ã€‚
2. å¦‚æœ `n` ä¸ºå¶æ•°ï¼Œåˆ™å°†å…¶é™¤ä»¥ 2ã€‚
3. å¦‚æœ `n` ä¸ºå¥‡æ•°ï¼Œåˆ™å°†å…¶ä¹˜ä»¥ 3 å¹¶åŠ  1ã€‚
4. ç»§ç»­æ­¤è¿‡ç¨‹ï¼Œç›´åˆ° `n` ä¸º 1ã€‚

è¿™ä¸ªæ•°å­— `n` ä¼šä¸Šä¸‹ç§»åŠ¨ï¼Œä½†æœ€ç»ˆä»¥1ç»“æŸï¼ˆè‡³å°‘å¯¹äºæ‰€æœ‰å°è¯•è¿‡çš„æ•°å­—æˆç«‹ - æ²¡æœ‰äººè¯æ˜åºåˆ—ä¼šç»ˆæ­¢ï¼‰ã€‚ç±»æ¯”äºå†°é›¹ï¼ˆhailstoneï¼‰åœ¨å¤§æ°”å±‚ä¸­ä¸Šä¸‹ç§»åŠ¨ï¼Œæœ€ç»ˆé™è½åœ¨åœ°çƒä¸Šã€‚`n` çš„å€¼åºåˆ—é€šå¸¸è¢«ç§°ä¸ºå†°é›¹åºåˆ—ã€‚ç¼–å†™ä¸€ä¸ªå‡½æ•°ï¼Œæ¥å—ä¸€ä¸ªæ­£å¼çš„å‚æ•°å `n`ï¼Œæ‰“å°å‡ºä» `n` å¼€å§‹çš„å†°é›¹åºåˆ—ï¼Œå¹¶è¿”å›åºåˆ—ä¸­çš„æ­¥æ•°ï¼šç¼–å†™å‡½æ•° `falling`ï¼Œæ¥å—ä¸¤ä¸ªå‚æ•° `n` å’Œ `k` ï¼Œ è¿”å› ä» `n` å¼€å§‹çš„å€’æ•° `k` ä¸ªè¿ç»­æ•°å­—ä¹‹ç§¯ã€‚å½“ `k` ä¸º `0` æ—¶ï¼Œå‡½æ•°è¿”å›`1`

**ä»£ç å®ç°**ï¼š

```python
def hailstone(n):
    """Print the hailstone sequence starting at n and return its
    length.

    >>> a = hailstone(10)
    10
    5
    16
    8
    4
    2
    1
    >>> a
    7
    >>> b = hailstone(1)
    1
    >>> b
    1
    """
    count = 1
    print(n)
    while n != 1:
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
        print(n)
        count += 1
    return count
```

æµ‹è¯•ç»“æœï¼š![img](https://github.com/Victor-Tau/cs61a/blob/master/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/figs/hw02/3.png?raw=True)

---

### 4. **`Product`**

å‡½æ•°è¦æ±‚ï¼šé«˜é˜¶å‡½æ•°è¯¾å ‚ä¸Šä»‹ç»çš„ `summation(n, term)` å°† `term(1) + ... + term(n)` åŠ èµ·æ¥ã€‚ç¼–å†™ä¸€ä¸ªç±»ä¼¼çš„å‡½æ•° `product` ï¼Œè¿”å› `term(1) * ... * term(n)` ã€‚

**ä»£ç å®ç°**ï¼š

```python
def product(n, term):
    """Return the product of the first n terms in a sequence.

    n: a positive integer
    term:  a function that takes one argument to produce the term

    >>> product(3, identity)  # 1 * 2 * 3
    6
    >>> product(5, identity)  # 1 * 2 * 3 * 4 * 5
    120
    >>> product(3, square)    # 1^2 * 2^2 * 3^2
    36
    >>> product(5, square)    # 1^2 * 2^2 * 3^2 * 4^2 * 5^2
    14400
    >>> product(3, increment) # (1+1) * (2+1) * (3+1)
    24
    >>> product(3, triple)    # 1*3 * 2*3 * 3*3
    162
    """
    result = 1
    for i in range(1, n + 1):
        result *= term(i)
    return result
```

æµ‹è¯•ç»“æœï¼š![img](https://github.com/Victor-Tau/cs61a/blob/master/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/figs/hw02/4.png?raw=True)

---

### 4. **`Accumulate`**

å‡½æ•°è¦æ±‚ï¼šè®©æˆ‘ä»¬çœ‹çœ‹ `summation` å’Œ `product` æ˜¯å¦‚ä½•æˆä¸ºæ›´åŠ æ³›åŒ–çš„å‡½æ•° `accumulate` çš„å®ä¾‹çš„ï¼Œè¯·å®ç°è¯¥å‡½æ•°ã€‚å®ç° `accumulate` åï¼Œå±•ç¤ºä¸€ä¸‹å®šä¹‰ `summation` å’Œ `product` æ—¶ï¼Œå¦‚ä½•é€šè¿‡è°ƒç”¨å‡½æ•° `accumulate` å®ç°çš„ã€‚

**é‡è¦**ï¼šä½ åº”è¯¥åœ¨ `summation_using_accumulate` å’Œ `product_using_accumulate` å®ç°ä¸­ç”¨ä¸€è¡Œä»£ç ï¼ˆåº”è¯¥æ—¶ä¸€ä¸ª `return` è¯­å¥ï¼‰ï¼Œä¼šæœ‰è¯­æ³•æ£€æŸ¥çš„

**ä»£ç å®ç°**ï¼š

```python
def accumulate(merger, start, n, term):
    """Return the result of merging the first n terms in a sequence and start.
    The terms to be merged are term(1), term(2), ..., term(n). merger is a
    two-argument commutative function.

    >>> accumulate(add, 0, 5, identity)  # 0 + 1 + 2 + 3 + 4 + 5
    15
    >>> accumulate(add, 11, 5, identity) # 11 + 1 + 2 + 3 + 4 + 5
    26
    >>> accumulate(add, 11, 0, identity) # 11
    11
    >>> accumulate(add, 11, 3, square)   # 11 + 1^2 + 2^2 + 3^2
    25
    >>> accumulate(mul, 2, 3, square)    # 2 * 1^2 * 2^2 * 3^2
    72
    >>> # 2 + (1^2 + 1) + (2^2 + 1) + (3^2 + 1)
    >>> accumulate(lambda x, y: x + y + 1, 2, 3, square)
    19
    >>> # ((2 * 1^2 * 2) * 2^2 * 2) * 3^2 * 2
    >>> accumulate(lambda x, y: 2 * x * y, 2, 3, square)
    576
    >>> accumulate(lambda x, y: (x + y) % 17, 19, 20, square)
    16
    """
    result = start
    for i in range(1, n + 1):
        result = merger(result, term(i))
    return result


def summation_using_accumulate(n, term):
    """Returns the sum: term(1) + ... + term(n), using accumulate.

    >>> summation_using_accumulate(5, square)
    55
    >>> summation_using_accumulate(5, triple)
    45
    >>> # You aren't expected to understand the code of this test.
    >>> # Check that the bodies of the functions are just return statements.
    >>> # If this errors, make sure you have removed the "***YOUR CODE HERE***".
    >>> import inspect, ast
    >>> [type(x).__name__ for x in ast.parse(inspect.getsource(summation_using_accumulate)).body[0].body]
    ['Expr', 'Return']
    """
    return accumulate(add, 0, n, term)


def product_using_accumulate(n, term):
    """Returns the product: term(1) * ... * term(n), using accumulate.

    >>> product_using_accumulate(4, square)
    576
    >>> product_using_accumulate(6, triple)
    524880
    >>> # You aren't expected to understand the code of this test.
    >>> # Check that the bodies of the functions are just return statements.
    >>> # If this errors, make sure you have removed the "***YOUR CODE HERE***".
    >>> import inspect, ast
    >>> [type(x).__name__ for x in ast.parse(inspect.getsource(product_using_accumulate)).body[0].body]
    ['Expr', 'Return']
    """
    return accumulate(mul, 1, n, term)
```

æµ‹è¯•ç»“æœï¼š![img](https://github.com/Victor-Tau/cs61a/blob/master/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/figs/hw02/5.png?raw=True)

---

### äº” å®éªŒå¿ƒå¾—

ä»£ç è¾ƒä¸ºç®€æ˜“ï¼Œä½¿ç”¨condaæ–°å»ºç¯å¢ƒpython=3.10ï¼Œè¿è¡Œæ­£å¸¸ã€‚å®éªŒæŠ¥å‘Šä½¿ç”¨vscodeå®‰è£…markdownæ’ä»¶ç¼–å†™ã€‚

å¼€å§‹åœ¨æœåŠ¡å™¨ä¸Šé…ç½®gitç®¡ç†ä½œä¸šä»£ç ã€‚ä½œä¸šä»£ç å·²å…¨éƒ¨æ‰˜ç®¡åˆ°github
![img](https://github.com/Victor-Tau/cs61a/blob/master/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/figs/hw02/0.png?raw=True)


